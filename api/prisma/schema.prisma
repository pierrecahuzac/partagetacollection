generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Enums - Définis en premier pour une meilleure lisibilité
enum Role {
    USER
    MODERATOR
    ADMIN
}

enum CollectionStatus {
    PRIVATE
    PUBLIC
    FRIENDS
}

enum Condition {
    NEUF
    TRES_BON_ETAT
    BON_ETAT
    MOYEN
    ABIME
    HS
}

enum UserRelationStatus {
    PENDING
    ACCEPTED
    REJECTED
    BLOCKED
}

// Modèles

model User {
    id                 String           @id @default(uuid())
    email              String           @unique
    username           String
    password           String
    role               Role             @default(USER)
    createdAt          DateTime         @default(now())
    updatedAt          DateTime         @updatedAt
    collections        Collection[]
    collectionItems    CollectionItem[]
    images             Image[]
    initiatedRelations UserRelation[]   @relation("UserRelation1")
    receivedRelations  UserRelation[]   @relation("UserRelation2")
    likeItems          LikeItem[]
}

model Collection {
    id              String           @id @default(uuid())
    title           String
    description     String?
    userId          String
    user            User             @relation(fields: [userId], references: [id])
    endingAt        DateTime?
    createdAt       DateTime         @default(now())
    updatedAt       DateTime         @updatedAt
    startedAt       DateTime         @default(now())
    status          CollectionStatus
    collectionItems CollectionItem[]
    formatType      FormatType?      @relation(fields: [formatTypeId], references: [id])
    formatTypeId    String?
    images          Image[]          @relation("CollectionImages")
}

model CollectionItem {
    id           String           @id @default(uuid())
    collectionId String
    itemId       String
    userId       String
    pricePaid    Float?
    quantity     Int              @default(1)
    condition    Condition?
    status       CollectionStatus @default(PRIVATE) // Statut de visibilité de l'exemplaire
    collection   Collection       @relation(fields: [collectionId], references: [id])
    item         Item             @relation(fields: [itemId], references: [id])
    user         User             @relation(fields: [userId], references: [id])
    images       Image[]          @relation("CollectionItemImage") // Nom de relation explicite
    createdAt    DateTime         @default(now())
    updatedAt    DateTime         @updatedAt

    @@map("collection_item")
}

model Item {
    id            String           @id @default(uuid())
    name          String
    description   String?
    barcode       String?
    createdAt     DateTime         @default(now())
    updatedAt     DateTime         @updatedAt
    images        Image[]          @relation("ItemImages")
    collections   CollectionItem[] // Liste des exemplaires de cet item possédés par des utilisateurs
    likeItems     LikeItem[]
    formatType    FormatType?      @relation(fields: [formatTypeId], references: [id])
    formatTypeId  String?
    // Attributs pour Single Table Inheritance (tous optionnels)
    author        String?
    isbn          String?
    publisher     String?
    language      String?
    artist        String?
    genre         String?
    audioDuration Int?
    director      String?
    videoDuration Int?
    videoEditor   String?
    platform      String?
    gameDeveloper String?
    gameEditor    String?
    country       String?
    material      String?
    denomination  String?
    year          Int?
}

model FormatType {
    id          String       @id @default(uuid())
    name        String       @unique
    collections Collection[]
    items       Item[]
}

model Image {
    id               String          @id @default(uuid())
    url              String
    itemId           String?
    item             Item?           @relation("ItemImages", fields: [itemId], references: [id], onDelete: Cascade)
    collectionId     String?
    collection       Collection?     @relation("CollectionImages", fields: [collectionId], references: [id], onDelete: Cascade)
    userId           String
    user             User            @relation(fields: [userId], references: [id])
    isCover          Boolean         @default(false)
    createdAt        DateTime        @default(now())
    updatedAt        DateTime        @updatedAt
    collectionItemId String? // Clé étrangère vers CollectionItem
    collectionItem   CollectionItem? @relation("CollectionItemImage", fields: [collectionItemId], references: [id], onDelete: Cascade) // Nom de relation cohérent

    @@index([itemId])
    @@index([collectionId])
    @@index([collectionItemId]) // Ajout de l'index pour la FK collectionItemId
    @@map("image")
}

model UserRelation {
    id             String             @id @default(uuid())
    user1Id        String             @map("user_1_id")
    user1          User               @relation("UserRelation1", fields: [user1Id], references: [id])
    user2Id        String             @map("user_2_id")
    user2          User               @relation("UserRelation2", fields: [user2Id], references: [id])
    dateDemande    DateTime           @default(now()) @map("date_demande")
    dateValidation DateTime?          @map("date_validation")
    status         UserRelationStatus @default(PENDING)

    @@unique([user1Id, user2Id])
    @@map("user_relation")
}

model LikeItem {
    id        String   @id @default(uuid())
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    itemId    String
    item      Item     @relation(fields: [itemId], references: [id])
    createdAt DateTime @default(now())

    @@unique([userId, itemId])
    @@map("like_item")
}
