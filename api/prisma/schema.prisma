generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String           @id @default(uuid())
  email            String           @unique
  username         String
  password         String
  role             Role             @default(USER)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  collections      Collection[]
  items            Item[]
  friends1         Friendship[]     @relation("FriendshipUser1")
  friends2         Friendship[]     @relation("FriendshipUser2")
  favorites        Favorite[]
  collectionsItems CollectionItem[]
}

model Friendship {
  id        String           @id @default(uuid())
  userId1   String
  userId2   String
  status    FriendshipStatus
  createdAt DateTime         @default(now())
  user1     User             @relation("FriendshipUser1", fields: [userId1], references: [id])
  user2     User             @relation("FriendshipUser2", fields: [userId2], references: [id])

  @@unique([userId1, userId2]) // Empêche les doublons
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Collection {
  id          String           @id @default(uuid())
  title       String
  description String
  userId      String
  user        User             @relation(fields: [userId], references: [id])
  endingAt    DateTime?
  isPublic    Boolean          @default(false)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  cover       String?
  startedAt   DateTime
  items       CollectionItem[]
  tags        Tag[]            @relation("CollectionToTag")
}

model CollectionItem {
  id           String @id @default(uuid())
  collectionId String
  itemId       String
  userId       String
  pricePaid    Float?
  quantity     Int    @default(1)

  collection Collection @relation(fields: [collectionId], references: [id])
  item       Item       @relation(fields: [itemId], references: [id])
  user       User       @relation(fields: [userId], references: [id])

  @@unique([collectionId, itemId, userId])
}

model Item {
  id           String           @id @default(uuid())
  name         String
  description  String
  price        Float
  userId       String
  user         User             @relation(fields: [userId], references: [id])
  quantity     Int
  barcode      String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  imageURL     String[]
  type         String
  isPublic     Boolean          @default(false)
  collections  CollectionItem[]
  tags         Tag[]            @relation("ItemToTag")
  audio        Audio?
  videoGame    VideoGame?
  video        Video?
  piece        Piece?
  favorites    Favorite[]
  //externalResources ExternalResource[]
  FormatType   FormatType?      @relation(fields: [formatTypeId], references: [id])
  formatTypeId String?
}

model Favorite {
  id        String   @id @default(uuid())
  userId    String
  itemId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  item Item @relation(fields: [itemId], references: [id])

  @@unique([userId, itemId]) // Un utilisateur ne peut pas mettre deux fois le même item en favori
}

// model ExternalResource {
//   id      String       @id @default(uuid())
//   itemId  String
//   url     String
//   type    ResourceType
//   addedAt DateTime     @default(now())

//   item Item @relation(fields: [itemId], references: [id])
// }

// enum ResourceType {
//   YOUTUBE
//   EBAY
//   WIKIPEDIA
// }

model Audio {
  id           String      @id @default(uuid())
  itemId       String      @unique
  artist       String
  year         Int
  formatType   FormatType? @relation(fields: [formatTypeId], references: [id])
  formatTypeId String?
  item         Item        @relation(fields: [itemId], references: [id])
}

model VideoGame {
  id           String      @id @default(uuid())
  itemId       String      @unique
  platform     String // "PS5", "Switch", "PC"
  editor       String
  year         Int
  item         Item        @relation(fields: [itemId], references: [id])
  formatType   FormatType? @relation(fields: [formatTypeId], references: [id])
  formatTypeId String?
}

model Video {
  id         String     @id @default(uuid())
  itemId     String     @unique
  formatType FormatType @relation(fields: [id], references: [id])
  editor     String
  year       Int
  item       Item       @relation(fields: [itemId], references: [id])
}

model FormatType {
  id         String      @id @default(uuid()) // Identifiant unique pour chaque format
  name       String      @unique
  items      Item[] // Relation avec les items (Audio/Video)
  videos     Video[]
  videoGames VideoGame[]
  audios      Audio[]
}

model Piece {
  id       String @id @default(uuid())
  itemId   String @unique
  country  String
  year     Int
  material String
  item     Item   @relation(fields: [itemId], references: [id])
}

model Tag {
  id          String       @id @default(uuid())
  name        String
  collections Collection[] @relation("CollectionToTag")
  items       Item[]       @relation("ItemToTag")
}

enum Role {
  USER
  MODERATOR
  ADMIN
}
